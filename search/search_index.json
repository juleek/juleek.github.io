{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"Temperature%20Monitoring/01.Intro/","title":"Intro / Overview","text":"<p>In this tutorial I am going to create a Temperature Monitoring and Alerting system that will:</p> <ul> <li>collect data from multiple temperature sensors of remote IoT devices RaspberryPi</li> <li>store the data in a DB Google Cloud BigQuery</li> <li>and notify users via a messenger Telegram</li> </ul> <p>The final result:</p> <p></p>"},{"location":"Temperature%20Monitoring/01.Intro/#architecture-design-principles","title":"Architecture &amp; Design principles","text":"<p>As you can see on the diagram below, there are two main data processing paths:</p> <ul> <li>write path what happens when there is new data from a sensor: we store data and check   if we need to send an alert</li> <li>read path what happens on cron: we read data for the last 24 hours, create a plot and notify   users in a group chat via Telegram.</li> </ul> <p></p> <p>Code-wise, I will focus on these main areas:</p> <ul> <li>fault-tolerance: for example:<ul> <li>all operations will be implemented idempotently and with retries.</li> <li>all errors will be propagated end-to-end (an error occured on RaspberryPi will be delivered   via Telegram).</li> </ul> </li> <li>extensibility: for example:<ul> <li>the <code>Ingest</code> module above will notify all subscribers via a uniform interface;</li> <li><code>BotNotifier</code> and <code>Alerting</code> are parameterised with a generic <code>Sender</code> interface   that can have many implementations (one of them, being Telegram).</li> </ul> </li> <li>unit-tests: running a wide gamut from simple unit-tests to unit-test with mocks &amp; patches,   as well as semi-manual integration tests.<ul> <li>For example, we will check that <code>Alerting</code> calls <code>send()</code> function of the <code>Sender</code> interface   if temperature drops below a threshold.</li> </ul> </li> </ul> <p>Below is a brief description of each of the components form the diagram above.</p>"},{"location":"Temperature%20Monitoring/01.Intro/#components","title":"Components","text":""},{"location":"Temperature%20Monitoring/01.Intro/#raspberry-pi","title":"Raspberry Pi","text":"<p>I will use RaspberryPi with two attached (physical) temperature sensors.</p> <p>It has a service (daemon) that continuously collects measurements from the sensors and sends them via an HTTP request to a google function, which publishes them to a Pub/Sub topic.</p> <p>Setup of RaspberryPi is desribed here.</p>"},{"location":"Temperature%20Monitoring/01.Intro/#topic","title":"Topic","text":"<p>Google Pub/Sub topic serves as a buffer/queue between producers (RaspberryPi) and consumer (Google Cloud Function, <code>Ingest</code> on the diagram above). The latter is triggered on each message in the topic.</p> <p>We create and configure the topic programmatically.</p>"},{"location":"Temperature%20Monitoring/01.Intro/#ingest","title":"Ingest","text":"<p>This is the main entry point for all incoming data from IoT devices.</p> <p><code>Ingest</code> canonicalises incoming json into our \u201cstandard\u201d python <code>dataclass DeviceDatum</code> that is used throughout the project, and which is one of the main data-types.</p> <p><code>Ingest</code> is parameterised with a list of abstract consumer interfaces (in our case, there are two consumers: <code>sensor_db</code> and <code>bot_alerting</code>) and then notifies each of them with <code>DeviceDatum</code> message.</p>"},{"location":"Temperature%20Monitoring/01.Intro/#alerting","title":"Alerting","text":"<p><code>Alerting</code> is parameterised with the <code>Sender</code> interface, <code>Alerting</code> implements the <code>Consumer</code> interface and receives <code>DeviceDatum</code> from <code>Ingest</code>. It then checks if temperature is lower than a threshold.</p> <p>If the temperature is lower, it uses <code>Sender</code> to notify users.</p>"},{"location":"Temperature%20Monitoring/01.Intro/#sender","title":"Sender","text":"<p>Sender is an abstract interface that allows the code to notify users in a messanger-agnostic way.</p> <p>I will have just one implementation of the interface \u2014 Telegram.</p>"},{"location":"Temperature%20Monitoring/01.Intro/#sensorsdb","title":"SensorsDB","text":"<p><code>sensor_db</code> implements the consumer interface, receives <code>DeviceDatum</code> from <code>Ingest</code> and uses sensors_db_bg to store data in BigQuery.</p>"},{"location":"Temperature%20Monitoring/01.Intro/#job-scheduler-czjqqkd5","title":"Job Scheduler cron","text":"<p>I register <code>on_cron</code> function in Cloud Cron service. The function uses <code>bot_notifier</code> for regular daily notifications.</p> <p>How to setup Google Cloud Cron see here.</p>"},{"location":"Temperature%20Monitoring/01.Intro/#bot-notifier","title":"Bot Notifier","text":"<p>bot_notifier is parameterised with a <code>Sender</code>, then, using <code>sensors_db_bq</code> it retrieves data from the database for the last 24 hours and creates a plot with a text message. It then uses <code>Sender</code> (which, in our case, is <code>telegram_sender</code>) to send message to a group chat.</p>"},{"location":"Temperature%20Monitoring/01.Intro/#telegram","title":"Telegram","text":"<p>How to create Telegram bot and register a webhook, see here.</p>"},{"location":"Temperature%20Monitoring/01.Intro/#virtual-machine","title":"Virtual machine","text":"<p>In order to be able to ssh to RaspberryPi, I need an intermediate VM with a static public IP address (I will use it to setup a reverse ssh tunnel).</p> <p>How to provision a virtual machine in Google Cloud you can find here.</p>"},{"location":"Temperature%20Monitoring/02.RaspberryPiSetup/","title":"Raspberry Pi","text":""},{"location":"Temperature%20Monitoring/02.RaspberryPiSetup/#install-raspbian","title":"Install Raspbian","text":"<p>Official docs.</p> <p>Download image, verify the checksum and write it on SD card:</p> <pre><code>wget https://downloads.raspberrypi.org/raspbian_lite_latest\necho \"9e5cf24ce483bb96e7736ea75ca422e3560e7b455eee63dd28f66fa1825db70e raspbian_lite_latest\" | sha256sum --check\nraspbian_lite_latest: OK\nunzip raspbian_lite_latest\nsudo dd bs=4M if=2019-07-10-raspbian-buster-lite.img of=/dev/sdX status=progress conv=fsync\n\n# Double-check it has been written successfully\nsudo dd bs=4M if=/dev/sda of=from-sd-card.img count=524\necho \"9e5cf24ce483bb96e7736ea75ca422e3560e7b455eee63dd28f66fa1825db70e from-sd-card.img\" | sha256sum --check\n</code></pre>"},{"location":"Temperature%20Monitoring/02.RaspberryPiSetup/#ssh","title":"SSH","text":"<ul> <li>Enable ssh-agent on your main host and copy your public ssh key to RPi: <code>ssh-copy-id pi@192.168.0.11 -p 222</code></li> <li> <p>Generate keys on RPi: <code>ssh-keygen -t ecdsa -b 521</code></p> </li> <li> <p>Enable SSH server on RPi     <pre><code>sudo systemctl enable ssh.service\nsudo systemctl start ssh.service\n</code></pre></p> </li> </ul>"},{"location":"Temperature%20Monitoring/02.RaspberryPiSetup/#setup-auto-screen-on-ssh-login","title":"Setup auto screen on ssh login","text":"nano ~/.bashrc<pre><code>+ # Auto-screen invocation. see: http://taint.org/wk/RemoteLoginAutoScreen\n+ # if we're coming from a remote SSH connection, in an interactive session\n+ # then automatically put us into a screen(1) session.   Only try once\n+ # -- if $STARTED_SCREEN is set, don't try it again, to avoid looping\n+ # if screen fails for some reason.\n+ if [ \"$PS1\" != \"\" -a \"${STARTED_SCREEN:-x}\" = x -a \"${SSH_TTY:-x}\" != x ]\n+ then\n+    STARTED_SCREEN=1 ; export STARTED_SCREEN\n+    screen -RR &amp;&amp; exit 0\n+    # normally, execution of this rc script ends here...\n+    echo \"Screen failed! continuing with normal bash startup\"\n+ fi\n+ # [end of auto-screen snippet]\n</code></pre> nano ~/.screenrc<pre><code># Enable scroll in screen\ndefscrollback 10000\ntermcapinfo xterm* ti@:te@\n\n# see http://www4.informatik.uni-erlangen.de/~jnweiger/screen-faq.html\n# support color X terminals\ntermcap  xterm 'XT:AF=\\E[3%dm:AB=\\E[4%dm:AX'\nterminfo xterm 'XT:AF=\\E[3%p1%dm:AB=\\E[4%p1%dm:AX'\ntermcapinfo xterm 'XT:AF=\\E[3%p1%dm:AB=\\E[4%p1%dm:AX:hs:ts=\\E]2;:fs=\\007:ds=\\E]2;screen\\007'\ntermcap  xtermc 'XT:AF=\\E[3%dm:AB=\\E[4%dm:AX'\nterminfo xtermc 'XT:AF=\\E[3%p1%dm:AB=\\E[4%p1%dm:AX'\ntermcapinfo xtermc 'XT:AF=\\E[3%p1%dm:AB=\\E[4%p1%dm:AX:hs:ts=\\E]2;:fs=\\007:ds=\\E]2;screen\\007'\n\n# auto-screen support; see http://taint.org/wk/RemoteLoginAutoScreen\n# detach on hangup\nautodetach on\n\n# no startup msg\nstartup_message off\n\n# always use a login shell\nshell -$SHELL\n</code></pre>"},{"location":"Temperature%20Monitoring/02.RaspberryPiSetup/#3g4g-usb-modem","title":"3g/4g usb modem","text":"<p>You can use any 3g/4g usb modem. For example one of these modems.</p> <p>After installing Raspberry Pi we need to initialise a system that will allow us to connect to Raspberry Pi via SSH access. For this we will setup a virtual machine using Google Cloud. The tutorial on how to do it is here.</p>"},{"location":"Temperature%20Monitoring/03.VM/","title":"VM","text":"<p>Prerequisites:</p> <ul> <li>I assume that you have Google Cloud account and</li> <li><code>gcloud</code> CLI</li> </ul>"},{"location":"Temperature%20Monitoring/03.VM/#create-vm","title":"Create VM","text":"<p>In this section, I will describe how to list and choose parameters required to create a VM instance, and then create it.</p> <ol> <li> <p>Authenticate in Google Cloud \u2014 <code>gcloud auth login</code></p> </li> <li> <p>You can set default project with <code>gcloud config set project project_name</code>, and unset it    with <code>gcloud config unset project</code>.</p> </li> <li> <p>Choose region and zone</p> <p>List regions along with available resources \u2014 <code>gcloud compute regions list --project project_name</code></p> <p>List zones \u2014 <code>gcloud compute zones list --project project_name</code></p> <p>Region picker \u2014 allows to pick the best region according to multiple metrics (compute price &amp; latency).</p> </li> <li> <p>Set default regions and zones for project:     <pre><code>gcloud compute project-info add-metadata                                                       \\\n--metadata google-compute-default-region=region_name,google-compute-default-zone=zone_name \\\n--project project_name\n</code></pre></p> </li> <li> <p>Choose image</p> <p>List images, families and image-projects \u2014 <code>gcloud compute images list --project project_name | grep -v -- \"-arm64\\|-pro-\" | grep -i \"PROJECT\\|FAMILY\\|ubuntu\"</code></p> <p>Pick \u201cimage project\u201d and \u201cimage family\u201d.</p> </li> <li> <p>Choose disk</p> Disk types and pricing <ul> <li>Description of different disk types   (such as <code>standard</code>, <code>balanced</code>, <code>ssd</code>, etc\u2026).</li> <li>Disks pricing.</li> </ul> <p>Each VM instance has at least one disk attached to it.</p> <p>List disk types \u2014 <code>gcloud compute disk-types list --filter=\"zone:( ezone_name )\" --project project_name</code></p> </li> <li> <p>Choose instance configuration</p> <ol> <li> <p>Choose machine family and series based on its    capabilities (range of cores, CPU manufacturer, RAM, etc\u2026). (1)</p> <ol> <li>N2D is good for confidential computing. <code>E2-standard</code> is good for cost. <code>E2-medium</code> is has even less    cost, but with shared core &amp; CPU bursting.</li> </ol> </li> <li> <p>Consider shared core &amp; CPU bursting (machine series <code>e2-micro</code>, <code>e2-small</code>, <code>e2-medium</code>).</p> </li> <li> <p>Choose security features:</p> <ul> <li>Confidential computing   (machine series <code>N2D</code>).</li> <li>Shielded VM   (secure boot, UEFI, TPM, Integrity monitoring).<ul> <li>List of images with Shielded VM support. If the image supports Shielded VM features,   the following line appears in the output of <pre><code>gcloud compute images describe IMAGE_NAME --project=project_name\ntype: UEFI_COMPATIBLE\n</code></pre></li> <li>Use these option during VM creation:   <code>--shielded-integrity-monitoring</code>, <code>--shielded-secure-boot</code>, <code>--shielded-vtpm</code> to enable it.   Or this command to enable   Shielded VM features in already existing VM.</li> </ul> </li> </ul> </li> <li> <p>Check availability in chosen region \u2014    <code>gcloud compute machine-types list --filter=\"zone:( zone_name )\" --project project_name</code>.</p> </li> <li> <p>Take into account pricing:</p> <ul> <li>Pricing of machines, disks, GPUs, etc\u2026</li> <li>Google Cloud Pricing Calculator.</li> <li>Consider 1 &amp; 3 year commitments.</li> </ul> </li> </ol> </li> </ol> <p>Finally, now we have all information to create our VM instance.</p> <pre><code>gcloud compute instances create vm_name      \\\n--image-family   image_family            \\\n--image-project  image_project           \\\n--boot-disk-size disk_size               \\\n--boot-disk-type disk_type               \\\n--machine-type   machine_type            \\\n--shielded-integrity-monitoring          \\\n--shielded-secure-boot                   \\\n--project project_name\n</code></pre> Other VM CRUD Doperations <ul> <li>Delete instance: <code>gcloud compute instances delete vm_name</code></li> <li>Stop instance: <code>gcloud compute instances stop vm_name</code></li> <li>Start instance: <code>gcloud compute instances start vm_name</code></li> </ul>"},{"location":"Temperature%20Monitoring/03.VM/#allocate-ip-address","title":"Allocate IP address","text":"<p>Allocate an IP address: <pre><code>gcloud compute addresses create vm_name-ip --region=region_name --project project_name\n</code></pre></p> <p>Delete existing ephemeral IP address:</p> <pre><code>gcloud compute instances delete-access-config vm_name --access-config-name=\"external-nat\" # (1)!\n</code></pre> <ol> <li>Where <code>external-nat</code> is a value of the <code>name</code> field from output of:     <pre><code>gcloud compute instances describe vm_name\nnetworkInterfaces:\n- accessConfigs:\n- kind: compute#accessConfig\n    name: external-nat\n    natIP: _________\n    networkTier: PREMIUM\n    type: ONE_TO_ONE_NAT\n</code></pre></li> </ol> <p>Finally, assign IP address to VM: <pre><code>gcloud compute instances add-access-config vm_name --access-config-name=\"external-nat\" --address=(gcloud compute addresses list --filter=\"name=('vm_name-ip')\" --format=\"get(address)\")\n</code></pre></p> Other IP CRUD operations <ul> <li>List IP addresses: <code>gcloud compute addresses list</code></li> <li>Delete IP address: <code>gcloud compute addresses delete vm_name-ip</code></li> </ul>"},{"location":"Temperature%20Monitoring/03.VM/#setup-the-vm","title":"Setup the VM","text":""},{"location":"Temperature%20Monitoring/03.VM/#initialise-users","title":"Initialise users","text":"<p>Open terminal in browser, add users and install packages:</p> <pre><code>sudo adduser --gecos \"\" --disabled-password user\nsudo usermod -a -G sudo user\nsudo apt update &amp;&amp; sudo apt full-upgrade -y &amp;&amp; sudo apt install -y nano git locate\n</code></pre> <p>Allow password-less <code>sudo</code>:</p> sudo visudo<pre><code>- %sudo   ALL=(ALL:ALL) ALL\n+ %sudo   ALL=(ALL:ALL) NOPASSWD:ALL\n</code></pre>"},{"location":"Temperature%20Monitoring/03.VM/#setup-ssh-access","title":"Setup SSH access","text":"<p><pre><code>sudo -u user bash -c \"mkdir -p ~/.ssh &amp;&amp; nano ~/.ssh/authorized_keys\"\n</code></pre> And copy your local ssh public key: <code>cat ~/.ssh/id_ed25519.pub</code> or <code>ssh-add -L</code> to <code>~/.ssh/authorized_keys</code>.</p> <p>Get host\u2019s ssh key fingerprint (to compare it with what local ssh will print when you connect to the VM from local host): <pre><code>ssh-keygen -lf &lt;(ssh-keyscan localhost 2&gt;/dev/null)\n</code></pre></p> <ol> <li>where the IP comes from output of: <code>gcloud compute addresses list --filter=\"name=('vm_name-ip')\" --format=\"get(address)\"</code></li> </ol>"},{"location":"Temperature%20Monitoring/03.VM/#setup-rpi-user","title":"Setup <code>rpi</code> user","text":"<ul> <li> <p><code>sudo adduser --gecos \"\" --disabled-password rpi</code> (1)</p> <ol> <li>Add the user</li> </ol> </li> <li> <p><code>mkdir -p  ~/.ssh &amp;&amp; nano ~/.ssh/authorized_keys &amp;&amp; exit</code> (1)</p> <ol> <li>Populate <code>~/.ssh/authorized_keys</code> with public key of pi user on RaspberryPi</li> </ol> </li> <li> <p><code>sudo usermod -s /usr/sbin/nologin rpi</code> (1)</p> <ol> <li>Set <code>nologin</code> shell to the <code>rpi</code> user</li> </ol> </li> </ul> <p>Tweak SSH config on the VM:</p> sudo nano /etc/ssh/sshd_config<pre><code>Match User rpi\n   PasswordAuthentication no\n   AllowTcpForwarding remote # yes\n   AllowStreamLocalForwarding no\n   X11Forwarding no\n   PermitTunnel no\n   GatewayPorts no\n   AllowAgentForwarding no\n   PermitOpen localhost:_____\n   ForceCommand echo 'This account can only be used for reverse ssh tunnelling'\n</code></pre>"},{"location":"Temperature%20Monitoring/03.VM/#connect-from-local-host-to-the-device","title":"Connect from local host to the device","text":"<p>Now you can use this VM IP as a bastion host (1) to connect to RaspberryPi.</p> <ol> <li> <p>Baston hosts are usually public-facing, hardened systems that serve as an entrypoint to systems behind a firewall or other restricted location, and they are especially popular with the rise of cloud computing</p> </li> </ol>"},{"location":"Temperature%20Monitoring/04.GoogleCloud/","title":"Google Cloud","text":""},{"location":"Temperature%20Monitoring/04.GoogleCloud/#bigquery","title":"BigQuery","text":"<p>I will be using BigQuery for storing the following data:</p> <ul> <li>primary temperature measurements and error messages</li> <li>chat IDs for Telegram bots.</li> </ul> <p>Python API</p> <ul> <li> <p>To run the client library, you must first set up authentication.</p> <ul> <li>Create the service account:<code>gcloud iam service-accounts create bgtest</code></li> <li> <p>Grant role <code>admin</code> to the service account. <pre><code>gcloud projects add-iam-policy-binding tarasovka --member=\"serviceAccount:bgtest@project_name.iam.gserviceaccount.com\" --role=roles/admin\n</code></pre></p> </li> <li> <p>Generate the key file: <pre><code>cd $HOME/devel/ &amp;&amp; gcloud iam service-accounts keys create bgtest.json --iam-account=bgtest@project_name.iam.gserviceaccount.com\n</code></pre></p> </li> <li> <p>Set <code>GOOGLE_APPLICATION_CREDENTIALS</code> env var: <pre><code>set -x GOOGLE_APPLICATION_CREDENTIALS \"______.json\"\n</code></pre></p> </li> </ul> </li> <li> <p>Install library in Python</p> <pre><code>pip3 install google-cloud-bigquery\n</code></pre> </li> </ul>"},{"location":"Temperature%20Monitoring/04.GoogleCloud/#google-functions","title":"Google Functions","text":"<p>I will use Google Function for the following tasks:</p> <ul> <li>process messages from IoT devices</li> <li>handle http requests from Telegram</li> <li>regular notification via Cron.</li> </ul> <p>How to deploy a Cloud Function</p> <p>Cloud Functions\u2019 arguments</p> <p>When deploying a new Cloud Function you nedd to specify \u2013trigger</p> <p>Example of Google Function with trigger-topic: <pre><code>gcloud functions deploy function_name                        \\\n--gen2                                                     \\\n--region=region_name                                       \\\n--trigger-topic=topic_name                                 \\\n--runtime=python310                                        \\\n--source=path_to_directory                                 \\\n--entry-point=function_name                                \\\n--allow-unauthenticated\n</code></pre></p> <p>Example of Google Function with trigger-http: <pre><code>gcloud functions deploy function_name                        \\\n--gen2                                                     \\\n--region=region_name                                       \\\n--trigger-http                                             \\\n--runtime=python310                                        \\\n--source=path_to_directory                                 \\\n--entry-point=function_name                                \\\n--allow-unauthenticated\n</code></pre></p> <p>If you wish to delete an exicting Google Function do this:</p> <pre><code>gcloud functions delete function_name --gen2 --region region_name\n</code></pre>"},{"location":"Temperature%20Monitoring/04.GoogleCloud/#job-sheduler","title":"Job Sheduler","text":"<p>For receiving data from sensors every day at the exact time you need to use Cron to shedule jobs.</p> <p>Setup cron job that sends a request at 6:00, 15:00, 18:00 (London time) every day:</p> <pre><code>gcloud sheduler jobs create http fucntion_name \\\n--location=path_to_function                  \\\n--shedule=\"0 6,15,18 1-31 1-12 0-7\"          \\\n--uri=\"\"                                     \\\n--http-method=GET                            \\\n--time-zone=zone_name\n</code></pre>"},{"location":"Temperature%20Monitoring/05.Telegram/","title":"Telegram","text":""},{"location":"Temperature%20Monitoring/05.Telegram/#create-bot","title":"Create Bot","text":"<p>Find \u201cBot Father\u201d bot in telegram, and then execute the following command: <code>/newbot</code>.</p> <p>It will give you bot id, remember it \u2014 it is a secret that identifies your bot.</p>"},{"location":"Temperature%20Monitoring/05.Telegram/#set-webhook","title":"Set webhook","text":"<p>When you setup a webhook, you essentially setup a mapping between your bot and an http end-point (URL). This URL is then used (\u201ccalled\u201d) by Telegram each time the bot gets a message from a user.</p> <ul> <li> <p>Set webhook:</p> With \"normal\" certificateWith self-signed certificate <pre><code>curl -v -X POST \"https://api.telegram.org/bot1111111111111111111111/setWebhook\" \\\n-H \"Content-Type: application/json\" --data '{ \"url\": \"https://your_ip\" }' # (1)!\n</code></pre> <ol> <li>HTTPS url must be provided for webhook. So, we need to run private/standalone https serve following the instruction below.</li> </ol> <pre><code>openssl req -newkey rsa:2048 -sha256 -nodes -keyout ~/devel/key.pem -x509 -days 365 -out ~/devel/cert.pem -subj \"/C=NG/ST=Lagos/L=Lagos/O=YOUR_ORG_NAME_HERE/CN=your_ip\"\ncurl -F \"url=https://your_ip\" \\\n-F \"certificate=./cert.pem\" \\\nhttps://api.telegram.org/bot1111111111111111111111/setWebhook\n</code></pre> <ul> <li>Get webhook info: <code>curl -v \"https://api.telegram.org/bot1111111111111111111111/getWebhookInfo\"</code></li> </ul> </li> <li> <p>Delete webhook: <code>curl -v \"https://api.telegram.org/bot1111111111111111111111/deleteWebhook\"</code></p> </li> </ul> Test webhook via private/standalone https server <ul> <li>Run server on VM:     sudo python3<pre><code>from http.server import HTTPServer, BaseHTTPRequestHandler\nimport ssl\nclass PrintingHandler(BaseHTTPRequestHandler):\ndef do_GET(self):\nprint(f'ip: {self.client_address}, requestline: {self.requestline}\\n\\npath: {self.path}\\n\\nheaders: {self.headers}')\ndef do_POST(self):\nrawData = self.rfile.read(int(self.headers['content-length'])).decode('utf-8')\nprint(f'ip: {self.client_address}, requestline: {self.requestline}\\n\\npath: {self.path}\\n\\nheaders: {self.headers}')\nprint(rawData)\nhttpd = HTTPServer(('0.0.0.0', 443), PrintingHandler)\nsslctx = ssl.SSLContext()\nsslctx.load_cert_chain('./cert.pem', \"./key.pem\", \"1234\")\nhttpd.socket = sslctx.wrap_socket(httpd.socket, server_side=True)\nhttpd.serve_forever()\n</code></pre></li> <li>after you created https server, in telegram app: find bot, write it</li> </ul>"},{"location":"Temperature%20Monitoring/05.Telegram/#send-message","title":"Send message","text":"<p>Now you can send messages on behalf of the bot like this:</p> <pre><code>curl \"https://api.telegram.org/bot1111111111111111111111/sendMessage?chat_id=--222222&amp;text={text}\"\n</code></pre> <p>where chat_id is id of destional group/chat where you want to send the message.</p>"}]}